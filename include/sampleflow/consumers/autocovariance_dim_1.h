// ---------------------------------------------------------------------
//
// Copyright (C) 2019 by the SampleFlow authors.
//
// This file is part of the SampleFlow library.
//
// The deal.II library is free software; you can use it, redistribute
// it, and/or modify it under the terms of the GNU Lesser General
// Public License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
// The full text of the license can be found in the file LICENSE.md at
// the top level directory of deal.II.
//
// ---------------------------------------------------------------------

#ifndef SAMPLEFLOW_CONSUMERS_AUTOCOVARIANCEDIM1_H
#define SAMPLEFLOW_CONSUMERS_AUTOCOVARIANCEDIM1_H

#include <sampleflow/consumer.h>
#include <sampleflow/types.h>
#include <mutex>

#include <boost/numeric/ublas/matrix.hpp>


namespace SampleFlow
{
  namespace Consumers
  {
    /**
     * A Consumer class that implements computing the running sample autocovariance function:
     * \hat\gamma(k)=\frac{1}{n}\sum_{t=1}^{n-k}{(x_{t+k}-\bar{x})(x_{t}-\bar{x})}
     *
     * ### Threading model ###
     *
     * The implementation of this class is thread-safe, i.e., its
     * consume() member function can be called concurrently and from multiple
     * threads.
     *
     *
     * @tparam InputType The C++ type used for the samples $x_k$. In
     *   order to compute covariances, the same kind of requirements
     *   have to hold as listed for the Covariance class.
     */
    template <typename InputType>
    class autocovariancedim1 : public Consumer<InputType>
    {
      public:
        /**
         * The data type of the elements of the input type.
         */

        using scalar_type = InputType;
        /**
         * The type of the information generated by this class, i.e., in which
         * the autocovariance function is computed. By itself, for autocovariance there should
         * be enough to use vector. However, because we keep updating autocovariance, we need to save
         * parts used in calculation
         */

        using value_type = boost::numeric::ublas::matrix<scalar_type>;

        /**
         * Constructor.
         */

        autocovariancedim1();

        /**
         * Process one sample by updating the previously computed covariance
         * matrix using this one sample.
         *
         * @param[in] sample The sample to process.
         * @param[in] aux_data Auxiliary data about this sample. The current
         *   class does not know what to do with any such data and consequently
         *   simply ignores it.
         */
        virtual
        void
        consume (InputType     sample,
                 AuxiliaryData aux_data) override;

        /**
         * A function that returns the covariance matrix computed from the
         * samples seen so far. If no samples have been processed so far, then
         * a default-constructed object of type InputType will be returned.
         *
         * @return The computed covariance matrix.
         */
        value_type
        get () const;

      private:
        /**
         * A mutex used to lock access to all member variables when running
         * on multiple threads.
         */

        mutable std::mutex mutex;

        /**
         * The current value of $\bar x_k$ as described in the introduction
         * of this class.
         */

        InputType           current_mean;

        /**
         * Currently describes lag of autocovariance
         */

        InputType 			k;

        /**
         * The current value of $\bar x_k$ as described in the introduction
         * of this class.
         */
        boost::numeric::ublas::matrix<scalar_type> current_autocovariationdim1_matrix;

        /**
        * Save previous sample value
        */

        boost::numeric::ublas::matrix<scalar_type> past_sample;
        boost::numeric::ublas::matrix<scalar_type> past_sample_replace;

        /**
         * The number of samples processed so far.
         */
        types::sample_index n_samples;
    };

    template <typename InputType>
    autocovariancedim1 <InputType>::
	autocovariancedim1  ()
      :
      n_samples (0)
    {}


    template <typename InputType>
    void
	autocovariancedim1 <InputType>::
    consume (InputType sample, AuxiliaryData /*aux_data*/)
    {
      std::lock_guard<std::mutex> lock(mutex);

      // If this is the first sample we see, initialize the matrix with
      // this sample. After the first sample, the autocovariance matrix
      // is the zero matrix since a single sample does not have any friends yet.

      //Set how long is our autocovariance tail
      k=10;

      if (n_samples == 0)
        {
          n_samples = 1;
          current_autocovariationdim1_matrix.resize (k,3);
          for (unsigned int i=0; i<k; ++i)
        	for (unsigned int j=0; j<2; ++j){
        		current_autocovariationdim1_matrix(i,j) = 0;
        	}
          current_mean = sample;
          past_sample.resize (k,1);
          past_sample_replace.resize (k,1);
          past_sample(0,0) = sample;
        }
      else if(n_samples < k)
		{
     	 ++n_samples;
    	for (unsigned int i=0; i<n_samples-1; ++i){
    		//Update first value (alpha)
    		    InputType alpha = sample;
    		    alpha *= past_sample(i,0);
    		    alpha -= current_autocovariationdim1_matrix(i,0);
    		    alpha /= n_samples;
    		    current_autocovariationdim1_matrix(i,0) += alpha;

    		//Update second value (beta)
    		    InputType beta = sample;
    			beta += past_sample(i,0);
    			beta -= current_autocovariationdim1_matrix(i,1);
    			beta /= n_samples;
    			current_autocovariationdim1_matrix(i,1) += beta;
    		}

    		//Save needed past values
    	for (unsigned int i=0; i<n_samples-1; ++i){
    		past_sample_replace(i+1,0)=past_sample(i,0);
    		}
    	past_sample_replace(0,0) = sample;
    	past_sample = past_sample_replace;

    	// Then also update the running mean:
    	 InputType update = sample;
    	          update -= current_mean;
    	          update /= n_samples;
    	          current_mean += update;
		}
     else
     {
        ++n_samples;
         	for (unsigned int i=0; i<k; ++i){
         		//Update first value (alpha)
         		    InputType alpha = sample;
         		    alpha *= past_sample(i,0);
         		    alpha -= current_autocovariationdim1_matrix(i,0);
         		    alpha /= n_samples;
         		   current_autocovariationdim1_matrix(i,0) += alpha;

         		//Update second value (beta)
         		    InputType beta = sample;
         			beta += past_sample(i,0);
         			beta -= current_autocovariationdim1_matrix(i,1);
         			beta /= n_samples;
         			current_autocovariationdim1_matrix(i,1) += beta;
         		}

         		//Save needed past values
         	for (unsigned int i=0; i<k-1; ++i){
         		past_sample_replace(i+1,0)=past_sample(i,0);
         		}
         	past_sample_replace(0,0) = std::move(sample);
         	past_sample = past_sample_replace;

         	// Then also update the running mean:
         	 InputType update = sample;
         	          update -= current_mean;
         	          update /= n_samples;
         	          current_mean += update;

          //Give autocovariance value
         	for (unsigned int i=0; i<k; ++i){
          current_autocovariationdim1_matrix(i,2) = current_autocovariationdim1_matrix(i,0);
          current_autocovariationdim1_matrix(i,2) -= current_mean* current_autocovariationdim1_matrix(i,1);
          current_autocovariationdim1_matrix(i,2) += (n_samples-1)*current_mean*current_mean/(n_samples);
         	}
     }
    }


    template <typename InputType>
    typename autocovariancedim1 <InputType>::value_type
	autocovariancedim1 <InputType>::
    get () const
    {
      std::lock_guard<std::mutex> lock(mutex);

      return current_autocovariationdim1_matrix;
    }

  }
}

#endif
